<!DOCTYPE html>
<html lang="ru" class="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ —Ü–≤–µ—Ç—É</title>
    <!-- VK Bridge -->
    <script src="https://unpkg.com/@vkontakte/vk-bridge/dist/browser.min.js"></script>
    <!-- Tone.js for Audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-light: #eef2f9;
            --text-light: #1c1e21;
            --tube-border-light: #cdd5e0;
            --primary-light: #4f46e5;
            --shadow-light: rgba(79, 70, 229, 0.15);
            --modal-bg-light: #ffffff;
            --locked-bg-light: #d1d5db;
            --locked-text-light: #9ca3af;
        }
        html.light {
            --bg-color: var(--bg-light);
            --text-color: var(--text-light);
            --tube-border-color: var(--tube-border-light);
            --primary-color: var(--primary-light);
            --shadow-color: var(--shadow-light);
            --modal-bg-color: var(--modal-bg-light);
            --locked-bg-color: var(--locked-bg-light);
            --locked-text-color: var(--locked-text-light);
        }
        html.dark {
            --bg-color: #111827;
            --text-color: #e5e7eb;
            --tube-border-color: #4b5563;
            --primary-color: #818cf8;
            --shadow-color: rgba(129, 140, 248, 0.2);
            --modal-bg-color: #1f2937;
            --locked-bg-color: #374151;
            --locked-text-color: #6b7280;
        }
        body {
            font-family: 'Nunito', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
            height: 100vh;
            width: 100vw;
        }
        .screen {
            height: 100%;
            width: 100%;
            animation: fadeIn 0.3s ease-in-out;
        }
        .screen.hidden { display: none; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        .main-menu-button {
            background-color: var(--primary-color);
            color: white;
            font-weight: 700; border-radius: 12px; padding: 12px 24px;
            text-transform: uppercase; box-shadow: 0 4px 14px 0 var(--shadow-color);
            transition: all 0.2s ease-in-out; border: none;
        }
        .main-menu-button:hover:not(:disabled) {
            transform: translateY(-2px); box-shadow: 0 6px 20px 0 var(--shadow-color);
        }
        .main-menu-button:disabled {
            background-color: var(--locked-bg-color);
            cursor: not-allowed;
            box-shadow: none;
        }
        .secondary-button {
             background-color: transparent; color: var(--primary-color);
             border: 2px solid var(--primary-color);
        }
        .tube-container {
            position: relative;
            width: var(--tube-width, 60px);
            height: var(--tube-height, 240px);
            background-color: transparent;
            border: 4px solid var(--tube-border-color);
            border-top: none;
            border-radius: 0 0 25px 25px;
            margin: var(--tube-margin, 10px); cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex; flex-direction: column-reverse;
            overflow: hidden;
        }
        .tube-container::before {
            content: '';
            position: absolute;
            top: -8px;
            left: -4px;
            right: -4px;
            height: 8px;
            background-color: var(--tube-border-color);
            border-radius: 5px 5px 0 0;
        }
        .tube-container.selected {
            transform: translateY(-20px) scale(1.05);
            box-shadow: 0 0 25px var(--primary-color);
        }
        .tube-container.pouring {
            transition: transform 0.4s ease-in-out; z-index: 10;
        }
        .liquid {
            width: 100%; transition: height 0.3s ease-in-out;
        }
        .modal { background-color: rgba(0, 0, 0, 0.6); }
        .modal-content { background-color: var(--modal-bg-color); }
        
        #theme-toggle-slider { background-color: #767676; }
        .slider-icon { font-size: 1.5rem; }
        #theme-toggle:checked + #theme-toggle-slider:before { transform: translateX(24px); }
        #theme-toggle-slider:before {
            content: ''; position: absolute;
            left: 4px; top: 4px; width: 24px; height: 24px;
            background-color: white; border-radius: 50%;
            transition: transform 0.3s ease;
        }
        .icon-button {
            background: none; border: none; padding: 8px;
            cursor: pointer; color: var(--text-color);
            display: flex; align-items: center; justify-content: center; gap: 4px;
            width: 44px; height: 44px;
            position: relative;
        }
        .icon-button svg {
            width: 28px; height: 28px; stroke-width: 2;
            stroke: currentColor; fill: none;
        }
        .icon-button.disabled { opacity: 0.4; cursor: not-allowed; }
        .ad-label {
            font-size: 0.6rem; font-weight: bold;
            background-color: var(--primary-color); color: white;
            padding: 1px 4px; border-radius: 4px;
        }
        .stats-table { width: 100%; border-collapse: collapse; font-size: 0.9rem; }
        .stats-table th, .stats-table td {
            padding: 8px 4px; text-align: center;
            border-bottom: 1px solid var(--tube-border-color);
        }
        .stats-table th { color: var(--primary-color); }
    </style>
</head>
<body class="flex items-center justify-center h-screen select-none">

    <audio id="bg-music" loop src="music.mp3"></audio>

    <!-- –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é -->
    <div id="main-menu" class="screen hidden flex flex-col items-center justify-center text-center p-8 h-full w-full max-w-md mx-auto">
        <h1 class="text-6xl font-black mb-2" style="color: var(--primary-color);">Color Sort</h1>
        <p class="mb-8 text-lg" style="color: var(--text-color);">–ü–µ—Ä–µ–ª–µ–π –∏ –æ—Ç—Å–æ—Ä—Ç–∏—Ä—É–π</p>
        
        <div class="w-full">
            <div id="level-selection-container" class="grid grid-cols-2 gap-4">
                <!-- Level buttons will be generated here -->
            </div>
            <div class="grid grid-cols-2 gap-4">
                 <button class="main-menu-button secondary-button col-span-2 mt-4" id="stats-button">–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</button>
                <button class="main-menu-button secondary-button col-span-2 mt-4" id="other-games-btn">–î—Ä—É–≥–∏–µ –∏–≥—Ä—ã</button>
            </div>
            <div class="flex justify-center items-center space-x-4 pt-6">
                <span class="slider-icon">‚òÄÔ∏è</span>
                <label for="theme-toggle" class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="theme-toggle" class="sr-only">
                    <div id="theme-toggle-slider" class="w-14 h-8 rounded-full"></div>
                </label>
                <span class="slider-icon">üåô</span>
            </div>
        </div>
    </div>

    <!-- –ò–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ -->
    <div id="game-screen" class="screen hidden">
        <div class="grid grid-rows-[auto_1fr_auto] h-full w-full max-w-lg mx-auto p-4">
            <div class="flex justify-between items-center mb-4 px-2">
                <div class="flex items-center">
                    <button onclick="showPauseMenu()" class="icon-button">
                        <svg viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    </button>
                    <button id="sound-toggle-btn" class="icon-button">
                        <svg id="sound-on-icon" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M19.114 5.636a9 9 0 010 12.728M16.463 8.288a5 5 0 010 7.424M6.75 8.25l4.72-4.72a.75.75 0 011.28.53v15.88a.75.75 0 01-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.01 9.01 0 012.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75z"></path></svg>
                        <svg id="sound-off-icon" class="hidden" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M17.25 9.75L19.5 12m0 0l2.25 2.25M19.5 12l-2.25 2.25M19.5 12l2.25-2.25M6.75 8.25l4.72-4.72a.75.75 0 011.28.53v15.88a.75.75 0 01-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.01 9.01 0 012.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75z"></path></svg>
                    </button>
                </div>
                <div class="text-center">
                    <div class="text-xl font-bold">–•–æ–¥—ã: <span id="move-count">0</span></div>
                    <div class="text-lg">–í—Ä–µ–º—è: <span id="timer">00:00</span></div>
                </div>
                <button id="undo-button" class="icon-button disabled">
                    <svg viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M3 10h10a8 8 0 018 8v2M3 10l4-4m-4 4l4 4"></path></svg>
                    <span id="undo-count" class="absolute top-1 right-1 bg-red-500 text-white text-xs font-bold w-5 h-5 rounded-full flex items-center justify-center">3</span>
                </button>
            </div>
            <div id="game-board" class="flex flex-wrap justify-center items-center content-center min-h-0"></div>
            <div id="bottom-bar" class="flex justify-center items-center pt-4 h-20"></div>
        </div>
    </div>
    
    <!-- –≠–∫—Ä–∞–Ω "–î—Ä—É–≥–∏–µ –∏–≥—Ä—ã" -->
    <div id="other-games-screen" class="screen hidden flex flex-col items-center justify-center p-4">
        <div class="w-full max-w-sm mx-auto text-center">
            <h1 class="text-3xl font-bold tracking-tight mb-6">–î—Ä—É–≥–∏–µ –∏–≥—Ä—ã</h1>
            <div id="other-games-container" class="grid grid-cols-3 gap-x-4 gap-y-5"></div>
            <button id="back-to-menu-btn" class="w-full mt-6 py-3 px-4 rounded-xl font-semibold text-lg secondary-button">–ù–∞–∑–∞–¥</button>
        </div>
    </div>

    <!-- –ú–æ–¥–∞–ª—å–Ω—ã–µ –æ–∫–Ω–∞ -->
    <div id="stats-modal" class="modal hidden fixed inset-0 z-50 flex items-center justify-center p-4">
        <div class="modal-content w-full max-w-sm p-6 rounded-2xl shadow-lg text-center">
            <h2 class="text-3xl font-bold mb-4" style="color: var(--primary-color);">–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</h2>
            <table class="stats-table">
                <thead><tr><th>–£—Ä–æ–≤–µ–Ω—å</th><th>–ü–æ–±–µ–¥</th><th>–í—Ä–µ–º—è</th></tr></thead>
                <tbody>
                    <tr><td>–õ–µ–≥–∫–æ</td><td id="games-played-easy">0</td><td id="best-time-easy">--:--</td></tr>
                    <tr><td>–°—Ä–µ–¥–Ω–µ</td><td id="games-played-medium">0</td><td id="best-time-medium">--:--</td></tr>
                    <tr><td>–°–ª–æ–∂–Ω–æ</td><td id="games-played-hard">0</td><td id="best-time-hard">--:--</td></tr>
                    <tr><td>–≠–∫—Å–ø–µ—Ä—Ç</td><td id="games-played-expert">0</td><td id="best-time-expert">--:--</td></tr>
                    <tr><td>–ë–µ–∑—É–º–∏–µ</td><td id="games-played-insane">0</td><td id="best-time-insane">--:--</td></tr>
                    <tr><td>–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ</td><td id="games-played-impossible">0</td><td id="best-time-impossible">--:--</td></tr>
                </tbody>
            </table>
            <button onclick="closeModal('stats-modal')" class="main-menu-button mt-6 w-full">–ó–∞–∫—Ä—ã—Ç—å</button>
        </div>
    </div>
    <div id="pause-modal" class="modal hidden fixed inset-0 z-50 flex items-center justify-center">
        <div class="modal-content w-11/12 max-w-sm p-6 rounded-2xl shadow-lg text-center">
            <h2 class="text-3xl font-bold mb-6" style="color: var(--primary-color);">–ü–∞—É–∑–∞</h2>
            <div class="flex flex-col space-y-4">
                <button onclick="resumeGame()" class="main-menu-button w-full">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button>
                <button onclick="restartGame(true)" class="main-menu-button secondary-button w-full">–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
                <button onclick="goToMainMenu()" class="main-menu-button secondary-button w-full">–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</button>
            </div>
        </div>
    </div>
    <div id="win-modal" class="modal hidden fixed inset-0 z-50 flex items-center justify-center">
        <div class="modal-content w-11/12 max-w-sm p-8 rounded-2xl shadow-lg text-center">
            <div class="text-6xl mb-4">üéâ</div>
            <h2 class="text-3xl font-bold mb-2" style="color: var(--primary-color);">–ü–æ–±–µ–¥–∞!</h2>
            <p class="mb-2">–£—Ä–æ–≤–µ–Ω—å –ø—Ä–æ–π–¥–µ–Ω –∑–∞ <span id="win-time"></span></p>
            <p class="mb-6">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ö–æ–¥–æ–≤: <span id="win-moves"></span></p>
            <div class="flex flex-col space-y-4">
                <button onclick="nextLevel()" class="main-menu-button w-full">–°–ª–µ–¥—É—é—â–∏–π —É—Ä–æ–≤–µ–Ω—å</button>
                <button onclick="goToMainMenu()" class="main-menu-button secondary-button w-full">–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const screens = {
            mainMenu: document.getElementById('main-menu'),
            game: document.getElementById('game-screen'),
            otherGames: document.getElementById('other-games-screen')
        };
        const levelSelectionContainer = document.getElementById('level-selection-container');
        const gameBoard = document.getElementById('game-board');
        const moveCountSpan = document.getElementById('move-count');
        const timerSpan = document.getElementById('timer');
        const undoButton = document.getElementById('undo-button');
        const undoCountSpan = document.getElementById('undo-count');
        const themeToggle = document.getElementById('theme-toggle');
        const bgMusic = document.getElementById('bg-music');
        
        // --- Game State ---
        let tubes = [], selectedTube = null, moveCount = 0, timerInterval = null, seconds = 0;
        let currentDifficulty = 'easy', history = [], isPaused = false;
        let undosLeft = 3;
        let vkUserId = null;
        let wasMusicPlaying = false;

        let gameData = {
            theme: 'light',
            isMuted: false,
            levelsCompletedSinceAd: 0,
            stats: { 
                gamesPlayed: { easy: 0, medium: 0, hard: 0, expert: 0, insane: 0, impossible: 0 },
                bestTime: { easy: Infinity, medium: Infinity, hard: Infinity, expert: Infinity, insane: Infinity, impossible: Infinity } 
            }
        };

        // --- Config ---
        const COLORS = ["#d90429", "#f77f00", "#fcc419", "#20c997", "#43a047", "#0077b6", "#03045e", "#7209b7", "#ff006e", "#8d5b4c", "#8d99ae", "#00b4d8", "#c72c71"];
        const LIQUID_LAYERS = 4;
        const UNDO_LIMIT = 3;
        const WINS_TO_UNLOCK = 10;
        const LEVEL_CONFIG = {
            easy:   { name: '–õ–µ–≥–∫–æ', tubes: 6, empty: 2, colors: 4 },
            medium: { name: '–°—Ä–µ–¥–Ω–µ', tubes: 9, empty: 2, colors: 7 },
            hard:   { name: '–°–ª–æ–∂–Ω–æ', tubes: 12, empty: 2, colors: 10 },
            expert: { name: '–≠–∫—Å–ø–µ—Ä—Ç', tubes: 15, empty: 2, colors: 13 },
            insane: { name: '–ë–µ–∑—É–º–∏–µ', tubes: 18, empty: 2, colors: 8, doubleColors: true },
            impossible: { name: '–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ', tubes: 24, empty: 2, colors: 11, doubleColors: true }
        };
        
        // --- Audio Manager ---
        const audioManager = {
            pourSynth: null,
            winSynth: null,
            isReady: false,

            init() {
                // –ó–∞–º–µ–Ω—è–µ–º NoiseSynth –Ω–∞ FMSynth –¥–ª—è –±–æ–ª–µ–µ –ø—Ä–∏—è—Ç–Ω–æ–≥–æ "–≤–æ–¥–Ω–æ–≥–æ" –∑–≤—É–∫–∞
                this.pourSynth = new Tone.FMSynth({
                    harmonicity: 1.5,
                    modulationIndex: 10,
                    detune: 0,
                    oscillator: {
                        type: "sine"
                    },
                    envelope: {
                        attack: 0.01,
                        decay: 0.2,
                        sustain: 0.1,
                        release: 0.5
                    },
                    modulation: {
                        type: "square"
                    },
                    modulationEnvelope: {
                        attack: 0.05,
                        decay: 0.1,
                        sustain: 0.3,
                        release: 0.5
                    }
                }).toDestination();
                this.pourSynth.volume.value = -12; // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –≥—Ä–æ–º–∫–æ—Å—Ç—å

                this.winSynth = new Tone.PolySynth(Tone.Synth, {
                     oscillator: { type: 'triangle8' },
                     envelope: { attack: 0.02, decay: 0.1, sustain: 0.3, release: 1 }
                }).toDestination();
                this.winSynth.volume.value = -10;
                
                this.isReady = true;
            },
            
            playSound(sound) {
                if (!this.isReady || gameData.isMuted) return;
                try {
                    if (sound === 'pour') {
                        // –ó–∞–ø—É—Å–∫–∞–µ–º –∑–≤—É–∫ —Å –ø–∞–¥–∞—é—â–µ–π –≤—ã—Å–æ—Ç–æ–π —Ç–æ–Ω–∞ –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ "–±—É–ª—å–∫"
                        this.pourSynth.triggerAttackRelease("C4", "8n");
                        this.pourSynth.frequency.setValueAtTime("C4", Tone.now());
                        this.pourSynth.frequency.linearRampToValueAtTime("G3", Tone.now() + 0.3);
                    }
                    if (sound === 'win') {
                        const now = Tone.now();
                        const notes = ['C4', 'E4', 'G4', 'C5', 'E5', 'G5'];
                        notes.forEach((note, i) => {
                            this.winSynth.triggerAttackRelease(note, '16n', now + i * 0.1);
                        });
                    }
                } catch(e) { console.error("Sound play error", e); }
            },

            toggleMute(forceState) {
                const newState = (typeof forceState === 'boolean') ? forceState : !gameData.isMuted;
                gameData.isMuted = newState;

                document.getElementById('sound-on-icon').classList.toggle('hidden', gameData.isMuted);
                document.getElementById('sound-off-icon').classList.toggle('hidden', !gameData.isMuted);
                
                if (gameData.isMuted) {
                    bgMusic.pause();
                } else {
                    bgMusic.play().catch(e => {});
                }

                if(typeof forceState === 'undefined') {
                    saveGameData();
                }
            }
        };

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', async () => {
            await init();
            
            bgMusic.volume = 0.3; 
            
            document.getElementById('stats-button').addEventListener('click', () => openModal('stats-modal'));
            document.getElementById('sound-toggle-btn').addEventListener('click', () => audioManager.toggleMute());
            undoButton.addEventListener('click', undoMove);
            themeToggle.addEventListener('change', () => setTheme(themeToggle.checked ? 'dark' : 'light'));
            window.addEventListener('resize', () => {
                if (!screens.game.classList.contains('hidden')) {
                     requestAnimationFrame(() => adjustTubeSize(tubes.length));
                }
            });
            document.getElementById('other-games-btn').addEventListener('click', () => showScreen('otherGames'));
            document.getElementById('back-to-menu-btn').addEventListener('click', () => showScreen('mainMenu'));
            document.getElementById('other-games-container').addEventListener('click', e => {
                const gameEl = e.target.closest('[data-app-id]');
                if (gameEl) vkBridge.send('VKWebAppOpenApp', { app_id: parseInt(gameEl.dataset.appId) });
            });
            
            document.body.addEventListener('click', async () => {
                 if (!audioManager.isReady) {
                    await Tone.start();
                    audioManager.init();
                    if(!gameData.isMuted) {
                        bgMusic.play().catch(e => {});
                    }
                 }
            }, { once: true });
        });
        
        async function init() {
            vkBridge.send('VKWebAppInit');
            
            vkBridge.subscribe(e => {
                if (e.detail.type === 'VKWebAppViewHide') {
                    if (!bgMusic.paused) {
                        wasMusicPlaying = true;
                        bgMusic.pause();
                    }
                }
                if (e.detail.type === 'VKWebAppViewRestore') {
                    if (wasMusicPlaying && !gameData.isMuted) {
                       bgMusic.play().catch(e => {});
                    }
                    wasMusicPlaying = false;
                }
            });

            try {
                const user = await vkBridge.send('VKWebAppGetUserInfo');
                vkUserId = user.id;
            } catch (error) {
                console.warn("Could not get VK User ID.", error);
                vkUserId = 'test_user';
            }
            await loadGameData();
            setTheme(gameData.theme);
            renderMenu();
            renderOtherGames();
            audioManager.toggleMute(gameData.isMuted);
            showScreen('mainMenu');
        }

        // --- Screen & Ad Management ---
        function showScreen(screenName) {
            Object.values(screens).forEach(s => s.classList.add('hidden'));
            screens[screenName].classList.remove('hidden');
            
            if (!gameData.isMuted) {
                bgMusic.play().catch(e => {});
            }
            
            if (screenName === 'game') {
                requestAnimationFrame(() => adjustTubeSize(tubes.length));
            }
            vkBridge.send('VKWebAppShowBannerAd', { banner_location: 'bottom' }).catch(e => {});
        }

        async function showRewardedAd() {
            try {
                const adData = await vkBridge.send('VKWebAppShowNativeAds', { ad_format: 'reward' });
                return adData.result === true;
            } catch (e) { console.error("Rewarded ad error:", e); return false; }
        }

        function showInterstitialAd() {
            gameData.levelsCompletedSinceAd++;
            if (gameData.levelsCompletedSinceAd >= 3) {
                vkBridge.send('VKWebAppShowInterstitialAd').catch(e => {});
                gameData.levelsCompletedSinceAd = 0;
            }
            saveGameData();
        }

        // --- Game Flow ---
        function startGame(difficulty) {
            currentDifficulty = difficulty;
            resetGame();
            showScreen('game');
        }
        
        function resetGame() {
            isPaused = false; moveCount = 0; seconds = 0; history = [];
            undosLeft = UNDO_LIMIT;
            updateMoveCount(); 
            updateUndoButtonUI(); 
            startTimer();
            generateLevel(currentDifficulty);
        }

        function restartGame(fromPause = false) {
            if (fromPause) closeModal('pause-modal');
            resetGame();
        }
        
        function nextLevel() {
            closeModal('win-modal');
            resetGame();
        }

        function goToMainMenu() {
            closeModal('pause-modal');
            closeModal('win-modal');
            stopTimer();
            renderMenu();
            showScreen('mainMenu');
        }

        // --- Level Generation & Rendering ---
        function renderMenu() {
            levelSelectionContainer.innerHTML = '';
            const difficulties = Object.keys(LEVEL_CONFIG);

            for (let i = 0; i < difficulties.length; i++) {
                const difficulty = difficulties[i];
                const config = LEVEL_CONFIG[difficulty];
                const prevDifficulty = i > 0 ? difficulties[i-1] : null;

                let isUnlocked = (difficulty === 'easy');
                let winsOnPrev = 0;
                if (prevDifficulty) {
                    winsOnPrev = gameData.stats.gamesPlayed[prevDifficulty] || 0;
                    if (winsOnPrev >= WINS_TO_UNLOCK) {
                        isUnlocked = true;
                    }
                }
                
                const isFullWidth = ['insane', 'impossible'].includes(difficulty);

                const button = document.createElement('button');
                button.className = `main-menu-button relative overflow-hidden ${isFullWidth ? 'col-span-2' : ''}`;
                button.onclick = () => startGame(difficulty);
                button.disabled = !isUnlocked;

                if (isUnlocked) {
                    button.textContent = config.name;
                } else {
                    button.innerHTML = `
                        <div class="flex items-center justify-center">
                           <svg class="w-6 h-6 mr-2" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 1a4.5 4.5 0 00-4.5 4.5V9H5a2 2 0 00-2 2v6a2 2 0 002 2h10a2 2 0 002-2v-6a2 2 0 00-2-2h-.5V5.5A4.5 4.5 0 0010 1zm3 8V5.5a3 3 0 10-6 0V9h6z" clip-rule="evenodd"></path></svg>
                           <span>${config.name}</span>
                        </div>
                        <div class="absolute bottom-1 right-2 text-xs font-bold text-white opacity-80">${winsOnPrev}/${WINS_TO_UNLOCK}</div>
                    `;
                }
                levelSelectionContainer.appendChild(button);
            }
        }

        function generateLevel(difficulty) {
            const config = LEVEL_CONFIG[difficulty];
            const tubesWithLiquid = config.tubes - config.empty;
            const levelColors = shuffleArray([...COLORS]).slice(0, config.colors);
            const layersPerColor = config.doubleColors ? LIQUID_LAYERS * 2 : LIQUID_LAYERS;
            let colorPool = levelColors.flatMap(color => Array(layersPerColor).fill(color));
            colorPool = shuffleArray(colorPool);
            tubes = [];
            for (let i = 0; i < tubesWithLiquid; i++) tubes.push({ id: i, liquids: colorPool.splice(0, LIQUID_LAYERS), isAnimating: false });
            for (let i = 0; i < config.empty; i++) tubes.push({ id: tubes.length, liquids: [], isAnimating: false });
            tubes.push({ id: tubes.length, liquids: [], isPlaceholder: true, isAnimating: false });
            
            if (isLevelSolved(tubes.filter(t => !t.isPlaceholder))) {
                return generateLevel(difficulty);
            }
            renderTubes();
        }

        function isLevelSolved(currentTubes) {
            return currentTubes.every(t => t.liquids.length === 0 || (t.liquids.length === LIQUID_LAYERS && new Set(t.liquids).size === 1));
        }

        function adjustTubeSize(tubeCount) {
            const boardHeight = gameBoard.clientHeight;
            const boardWidth = gameBoard.clientWidth;
            if(!boardHeight || !boardWidth) return;
            let bestLayout = { cols: 0, tubeHeight: 0 };

            for (let cols = tubeCount; cols >= 1; cols--) {
                const rows = Math.ceil(tubeCount / cols);
                const cellWidth = boardWidth / cols;
                const cellHeight = boardHeight / rows;
                const prospectiveTubeWidth = cellWidth * 0.8;
                const prospectiveTubeHeight = prospectiveTubeWidth * 4;
                if (prospectiveTubeHeight < cellHeight * 0.95) {
                    if (prospectiveTubeHeight > bestLayout.tubeHeight) {
                        bestLayout = { cols: cols, tubeHeight: prospectiveTubeHeight };
                    }
                }
            }
            if(bestLayout.cols === 0) bestLayout.cols = tubeCount <= 12 ? 4 : 5;
            
            const finalTubeWidth = (boardWidth / bestLayout.cols) * 0.8;
            const finalTubeHeight = finalTubeWidth * 4;
            const finalTubeMargin = (boardWidth / bestLayout.cols) * 0.1;

            document.documentElement.style.setProperty('--tube-width', `${finalTubeWidth}px`);
            document.documentElement.style.setProperty('--tube-height', `${finalTubeHeight}px`);
            document.documentElement.style.setProperty('--tube-margin', `${finalTubeMargin}px`);
        }

        // --- Rendering ---
        function renderTubes() {
            gameBoard.innerHTML = '';
            tubes.forEach(tube => {
                const tubeEl = document.createElement('div');
                tubeEl.className = 'tube-container';
                tubeEl.dataset.id = tube.id;
                
                if (tube.isPlaceholder) {
                    tubeEl.style.borderStyle = 'dashed';
                    tubeEl.innerHTML = `<div class="m-auto flex flex-col items-center justify-center h-full"><span class="text-3xl font-bold" style="color: var(--primary-color)">+</span><span class="ad-label">AD</span></div>`;
                    tubeEl.addEventListener('click', () => unlockExtraTube(tube.id));
                } else {
                    tubeEl.addEventListener('click', () => onTubeClick(tube.id));
                    tube.liquids.forEach(color => {
                        const liquidEl = document.createElement('div');
                        liquidEl.className = 'liquid';
                        liquidEl.style.backgroundColor = color;
                        liquidEl.style.height = `${100 / LIQUID_LAYERS}%`;
                        tubeEl.appendChild(liquidEl);
                    });
                }
                gameBoard.appendChild(tubeEl);
            });
        }
        
        function renderOtherGames() {
            const container = document.getElementById('other-games-container');
            container.innerHTML = '';
            const games = [
                { name: 'Bubble Shooter', appId: 54051411, icon: 'icon1.png' }, { name: '–¢–µ—Ç—Ä–∏—Å', appId: 54051413, icon: 'icon2.png' },
                { name: 'Tower Blocks', appId: 53962513, icon: 'icon3.png' }, { name: '–ë–ª–æ–∫ –ü—Ä–æ', appId: 53936296, icon: 'icon4.png' },
                { name: '–§–∏–ª–≤–æ—Ä–¥—ã', appId: 53867134, icon: 'icon5.png' }, { name: '–°–ª–æ–≤–ª–∏', appId: 53861990, icon: 'icon6.png' },
                { name: 'Brick Balls', appId: 54023580, icon: 'icon7.png' }, { name: '2048', appId: 53965380, icon: 'icon8.png' },
                { name: 'Math Matrix', appId: 53970659, icon: 'icon9.png' }
            ];
            games.forEach(game => {
                const gameEl = document.createElement('div');
                gameEl.className = "flex flex-col items-center cursor-pointer group";
                gameEl.dataset.appId = game.appId;
                gameEl.innerHTML = `
                    <div class="w-20 h-20 bg-gray-200 dark:bg-gray-700 rounded-3xl mb-2 flex items-center justify-center group-hover:scale-105 transition-transform overflow-hidden">
                       <img src="${game.icon}" alt="${game.name}" class="w-full h-full object-cover">
                    </div>
                    <span class="text-xs font-medium text-center">${game.name}</span>`;
                container.appendChild(gameEl);
            });
        }

        // --- Game Logic ---
        function onTubeClick(tubeId) {
            if (isPaused) return;

            const clickedTubeData = tubes.find(t => t.id === tubeId);
            if (clickedTubeData.isPlaceholder || clickedTubeData.isAnimating) return;

            const tubeEl = document.querySelector(`.tube-container[data-id='${tubeId}']`);

            if (selectedTube === null) {
                if (clickedTubeData.liquids.length > 0) {
                    selectedTube = clickedTubeData;
                    tubeEl.classList.add('selected');
                }
            } else {
                const currentSelectedTube = selectedTube;
                const selectedEl = document.querySelector('.tube-container.selected');
                
                selectedTube = null;
                selectedEl?.classList.remove('selected');

                if (currentSelectedTube.id === clickedTubeData.id) {
                   return; // Deselected
                }
                
                if (canPour(currentSelectedTube, clickedTubeData)) {
                    saveState();
                    initiatePour(currentSelectedTube, clickedTubeData);
                }
            }
        }

        function canPour(from, to) {
            if (!from || !to || from.isAnimating || to.isAnimating) return false;
            if (from.liquids.length === 0 || to.liquids.length === LIQUID_LAYERS) return false;
            if (to.liquids.length === 0) return true;
            return from.liquids[from.liquids.length - 1] === to.liquids[to.liquids.length - 1];
        }

        function initiatePour(fromTube, toTube) {
            moveCount++;
            updateMoveCount();
            
            const topColor = fromTube.liquids[fromTube.liquids.length - 1];
            let amountToMove = fromTube.liquids.slice().reverse().findIndex(c => c !== topColor);
            if (amountToMove === -1) amountToMove = fromTube.liquids.length;
            amountToMove = Math.min(amountToMove, LIQUID_LAYERS - toTube.liquids.length);
            const liquidsToMove = fromTube.liquids.splice(fromTube.liquids.length - amountToMove);
            toTube.liquids.push(...liquidsToMove);

            animatePour(fromTube, toTube, liquidsToMove);
        }
        
        async function animatePour(fromTube, toTube, liquidsMoved) {
            fromTube.isAnimating = true;
            toTube.isAnimating = true;
            updateUndoButtonUI(); // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–Ω–æ–ø–∫–∏ –ø–µ—Ä–µ–¥ –∞–Ω–∏–º–∞—Ü–∏–µ–π

            const fromEl = document.querySelector(`.tube-container[data-id='${fromTube.id}']`);
            const toEl = document.querySelector(`.tube-container[data-id='${toTube.id}']`);

            fromEl.classList.add('pouring');
            
            audioManager.playSound('pour');
            const fromRect = fromEl.getBoundingClientRect();
            const toRect = toEl.getBoundingClientRect();
            const rotation = (toRect.x > fromRect.x) ? 20 : -20;
            fromEl.style.transformOrigin = 'top center';
            let moveX = (toRect.left + toRect.width / 2) - (fromRect.left + fromRect.width / 2);
            let moveY = toRect.top - fromRect.top - fromRect.height / 2;
            
            fromEl.style.transform = `translate(${moveX}px, ${moveY}px)`;
            await wait(200);
            fromEl.style.transform = `translate(${moveX}px, ${moveY}px) rotate(${rotation}deg)`;
            
            const liquidElsToRemove = Array.from(fromEl.querySelectorAll('.liquid')).slice(-liquidsMoved.length);
            liquidElsToRemove.forEach(el => el.style.height = '0%');
            await wait(300);
            liquidElsToRemove.forEach(el => el.remove());

            for (const color of liquidsMoved.slice().reverse()) {
                const newLiquid = document.createElement('div');
                newLiquid.className = 'liquid';
                newLiquid.style.backgroundColor = color;
                newLiquid.style.height = '0%';
                toEl.appendChild(newLiquid);
                await wait(1);
                newLiquid.style.height = `${100 / LIQUID_LAYERS}%`;
                await wait(50);
            }
            
            await wait(200);
            fromEl.style.transform = `translate(${moveX}px, ${moveY}px)`;
            await wait(200);
            fromEl.style.transform = 'translate(0, 0)';
            await wait(300);

            fromEl.classList.remove('pouring');
            fromTube.isAnimating = false;
            toTube.isAnimating = false;
            updateUndoButtonUI(); // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–Ω–æ–ø–∫–∏ –ø–æ—Å–ª–µ –∞–Ω–∏–º–∞—Ü–∏–∏
            
            const isAnyTubeAnimating = tubes.some(t => t.isAnimating);
            if (!isAnyTubeAnimating && isLevelSolved(tubes.filter(t => !t.isPlaceholder))) {
                winGame();
            }
        }

        async function unlockExtraTube(tubeId) {
            const tube = tubes.find(t => t.id === tubeId);
            if (tube.isAnimating) return;
            const adShown = await showRewardedAd();
            if (adShown) {
                saveState();
                if (tube) {
                    tube.isPlaceholder = false;
                    renderTubes();
                }
            }
        }
        
        function winGame() {
            stopTimer();
            audioManager.playSound('win');
            gameData.stats.gamesPlayed[currentDifficulty] = (gameData.stats.gamesPlayed[currentDifficulty] || 0) + 1;
            if (seconds < gameData.stats.bestTime[currentDifficulty]) {
                gameData.stats.bestTime[currentDifficulty] = seconds;
            }
            showInterstitialAd();
            saveGameData();
            updateStatsDisplay();
            document.getElementById('win-time').textContent = formatTime(seconds);
            document.getElementById('win-moves').textContent = moveCount;
            openModal('win-modal');
        }
        
        function saveState() {
            const stateToSave = tubes.map(t => ({
                id: t.id,
                liquids: [...t.liquids],
                isPlaceholder: t.isPlaceholder
            }));
            history.push(stateToSave);
            if (history.length > 20) history.shift();
            updateUndoButtonUI();
        }

        function undoMove() {
            const isAnyTubeAnimating = tubes.some(t => t.isAnimating);
            if (history.length > 0 && !isAnyTubeAnimating && undosLeft > 0) {
                undosLeft--;
                const prevState = history.pop();
                
                tubes.forEach(tube => {
                    const prevTube = prevState.find(pt => pt.id === tube.id);
                    if (prevTube) {
                        tube.liquids = [...prevTube.liquids];
                        tube.isPlaceholder = prevTube.isPlaceholder;
                    }
                });

                moveCount--;
                updateMoveCount();
                renderTubes();
                updateUndoButtonUI();
            }
        }
        
        function updateUndoButtonUI() {
            undoCountSpan.textContent = undosLeft;
            const isAnyTubeAnimating = tubes.some(t => t.isAnimating);
            const isDisabled = history.length === 0 || undosLeft <= 0 || isAnyTubeAnimating;
            undoButton.classList.toggle('disabled', isDisabled);
        }

        // --- UI & Timer ---
        function startTimer() { stopTimer(); timerInterval = setInterval(() => { if (!isPaused) { seconds++; timerSpan.textContent = formatTime(seconds); }}, 1000); }
        function stopTimer() { clearInterval(timerInterval); }
        function formatTime(s) { return `${Math.floor(s/60).toString().padStart(2,'0')}:${(s%60).toString().padStart(2,'0')}`; }
        function updateMoveCount() { moveCountSpan.textContent = moveCount; }
        function showPauseMenu() { isPaused = true; openModal('pause-modal'); }
        function resumeGame() { isPaused = false; closeModal('pause-modal'); }
        function openModal(id) { document.getElementById(id).classList.remove('hidden'); }
        function closeModal(id) { document.getElementById(id).classList.add('hidden'); }
        
        // --- Data & Theme ---
        function setTheme(theme) {
            gameData.theme = theme;
            document.documentElement.classList.toggle('dark', theme === 'dark');
            themeToggle.checked = theme === 'dark';
            saveGameData();
        }

        async function saveGameData() {
            if (!vkUserId) return;
            const storageKey = `colorsort_data_${vkUserId}`;
            try {
                await vkBridge.send('VKWebAppStorageSet', { key: storageKey, value: JSON.stringify(gameData) });
            } catch (error) {
                localStorage.setItem(storageKey, JSON.stringify(gameData));
            }
        }

        async function loadGameData() {
            if (!vkUserId) return;
            const storageKey = `colorsort_data_${vkUserId}`;
            let loadedData = null;
            try {
                const response = await vkBridge.send('VKWebAppStorageGet', { keys: [storageKey] });
                if (response.keys[0]?.value) loadedData = JSON.parse(response.keys[0].value);
            } catch (error) {
                const localData = localStorage.getItem(storageKey);
                if (localData) loadedData = JSON.parse(localData);
            }
            if (loadedData) {
                if (loadedData.stats && loadedData.stats.bestTime) {
                    for (const diff in loadedData.stats.bestTime) {
                        if (loadedData.stats.bestTime[diff] === null) {
                            loadedData.stats.bestTime[diff] = Infinity;
                        }
                    }
                }
                gameData.stats.bestTime = {...gameData.stats.bestTime, ...loadedData.stats?.bestTime };
                gameData.stats.gamesPlayed = {...gameData.stats.gamesPlayed, ...loadedData.stats?.gamesPlayed };
                gameData.theme = loadedData.theme || 'light';
                gameData.isMuted = loadedData.isMuted || false;
                gameData.levelsCompletedSinceAd = loadedData.levelsCompletedSinceAd || 0;
            }
            updateStatsDisplay();
        }

        function updateStatsDisplay() {
            if (!gameData.stats) return;
            Object.keys(gameData.stats.bestTime).forEach(diff => {
                const bestTimeEl = document.getElementById(`best-time-${diff}`);
                const gamesPlayedEl = document.getElementById(`games-played-${diff}`);
                if (bestTimeEl) bestTimeEl.textContent = gameData.stats.bestTime[diff] === Infinity ? '--:--' : formatTime(gameData.stats.bestTime[diff]);
                if(gamesPlayedEl) gamesPlayedEl.textContent = (gameData.stats.gamesPlayed && gameData.stats.gamesPlayed[diff]) || 0;
            });
        }

        // --- Helpers ---
        function shuffleArray(a) { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a; }
        function wait(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

    </script>
</body>
</html>

